<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>新年快乐 - 魏冰冰专属版</title>
    <style>
        * {
            padding: 0;
            margin: 0;
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #050505;
            /* 替换为用户指定的本地图片，并确保背景覆盖整个屏幕 */
            background-image: url('背景.jpg');
            background-size: 100% 100%; /* 强制拉伸填满屏幕 */
            background-position: center;
            background-repeat: no-repeat;
            background-attachment: fixed;
            font-family: "Microsoft YaHei", "PingFang SC", sans-serif;
            height: 100vh;
            width: 100vw;
        }

        /* 移除遮罩层，让背景图片完全清晰可见 */
        .bg-overlay {
            display: none;
        }

        /* 弹窗样式：模拟 1111.html */
        .love-popup {
            position: fixed;
            width: 260px;
            height: 120px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            background-color: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(5px);
            padding: 10px;
            box-sizing: border-box;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: popup-fade 0.5s ease-out;
            pointer-events: auto;
        }

        @keyframes popup-fade {
            from { opacity: 0; transform: scale(0.8) translateY(20px); }
            to { opacity: 1; transform: scale(1) translateY(0); }
        }

        .popup-message {
            font-size: 18px;
            color: #333;
            font-weight: bold;
            line-height: 1.4;
            text-align: center;
        }

        .popup-close {
            position: absolute;
            top: 5px;
            right: 8px;
            font-size: 16px;
            cursor: pointer;
            color: #999;
            background: none;
            border: none;
        }

        /* 优化 Canvas 层级 */
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            touch-action: none;
            background: transparent; /* 强制透明背景 */
        }
        #stars { z-index: -1; opacity: 0.6; } /* 稍微降低星星亮度，以免干扰背景 */
        #fireworks { z-index: 1; }
        #lovexf { z-index: 2; pointer-events: none; }

        #ui-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        #loveText {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            perspective: 1200px;
            z-index: 100;
            margin-bottom: 80px; /* 增加底部边距，让文字整体上移，不压心形 */
        }

        .char {
            display: inline-block;
            font-size: 3.5rem;
            font-weight: 900;
            opacity: 0;
            transform: translateZ(-1000px) rotateX(180deg) scale(0.5);
            transition: all 1s cubic-bezier(0.34, 1.56, 0.64, 1);
            margin: 0 8px;
            color: #d02090; /* 初始颜色改为紫色 (VioletRed) */
            text-shadow: 0 0 10px rgba(208, 32, 144, 0.5);
            filter: blur(10px);
        }

        .char.show {
            opacity: 1;
            transform: translateZ(0) rotateX(0) scale(1);
            filter: blur(0);
        }

        @media (max-width: 768px) {
            .char { font-size: 2.2rem; margin: 0 4px; }
            .love-popup { width: 200px; height: 100px; }
            .popup-message { font-size: 15px; }
        }

        .hint {
            color: #ffc0cb; /* 改为粉红色 (Pink) */
            font-size: 14px;
            position: absolute;
            bottom: 30px;
            z-index: 10;
            letter-spacing: 2px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .click-hint {
            position: absolute;
            top: 30px;
            color: #ff69b4; /* 改为热粉色 (HotPink)，稍微深一点以便看清 */
            font-size: 12px;
            letter-spacing: 1px;
        }
    </style>
</head>
<body>
    <div class="bg-overlay"></div>
    <canvas id="stars"></canvas>
    <canvas id="fireworks"></canvas>
    <canvas id="lovexf"></canvas>
    
    <div id="ui-layer">
        <div id="loveText"></div>
        <div class="click-hint">点击屏幕 绽放更多烟花</div>
        <div class="hint">2026 · 新年快乐 · 万事如意</div>
    </div>

    <!-- 节日背景音乐 -->
    <audio id="music" src="https://m801.music.126.net/20240101120000/romantic_festive.mp3" loop></audio>

    <script>
        // --- 基础配置 ---
        const starsCanvas = document.getElementById('stars');
        const starsCtx = starsCanvas.getContext('2d');
        const fwCanvas = document.getElementById('fireworks');
        const fwCtx = fwCanvas.getContext('2d');
        const loveCanvas = document.getElementById('lovexf');
        const loveCtx = loveCanvas.getContext('2d');
        const loveTextContainer = document.getElementById('loveText');
        const music = document.getElementById('music');

        let width, height;
        let startFireworks = true; // 初始状态为true，由时序控制逻辑控制何时停止
        let startHeart = false;    // 初始状态为false
        let isFireworksStage = true; // 标志位：是否处于烟花阶段
        let heartScale = 0;        // 爱心缩放比例，控制从小到大显示

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            [starsCanvas, fwCanvas, loveCanvas].forEach(canvas => {
                canvas.width = width * window.devicePixelRatio;
                canvas.height = height * window.devicePixelRatio;
                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';
            });
            starsCtx.scale(window.devicePixelRatio, window.devicePixelRatio);
            fwCtx.scale(window.devicePixelRatio, window.devicePixelRatio);
            initStars();
        }

        window.addEventListener('resize', resize);

        // --- 星空背景逻辑 ---
        let stars = [];
        let nebulae = [];
        function initStars() {
            stars = [];
            for (let i = 0; i < 400; i++) { // 增加星星数量
                stars.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    size: Math.random() * 1.8,
                    opacity: Math.random(),
                    speed: Math.random() * 0.03 + 0.01
                });
            }
            
            // 初始化星云/光晕效果
            nebulae = [];
            for (let i = 0; i < 5; i++) {
                nebulae.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    radius: Math.random() * 300 + 200,
                    color: `rgba(${Math.floor(Math.random()*100+50)}, ${Math.floor(Math.random()*50)}, ${Math.floor(Math.random()*150+100)}, 0.15)`,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: (Math.random() - 0.5) * 0.5
                });
            }
        }

        function drawStars() {
            // 使用 clearRect 而不是 fillRect 来清除画布
            // 确保不会用黑色覆盖背景图
            starsCtx.clearRect(0, 0, width, height);
            
            // 绘制星云时降低透明度
            nebulae.forEach(n => {
                const grad = starsCtx.createRadialGradient(n.x, n.y, 0, n.x, n.y, n.radius);
                grad.addColorStop(0, n.color);
                grad.addColorStop(1, 'transparent');
                starsCtx.fillStyle = grad;
                starsCtx.fillRect(0, 0, width, height);
                
                n.x += n.vx;
                n.y += n.vy;
                if (n.x < 0 || n.x > width) n.vx *= -1;
                if (n.y < 0 || n.y > height) n.vy *= -1;
            });

            stars.forEach(star => {
                starsCtx.beginPath();
                starsCtx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                starsCtx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`;
                starsCtx.fill();
                star.opacity += star.speed;
                if (star.opacity > 1 || star.opacity < 0) star.speed = -star.speed;
            });
            requestAnimationFrame(drawStars);
        }

        // --- 烟花逻辑 (增强版) ---
        class Particle {
            constructor(x, y, color, velocity) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.radius = Math.random() * 2 + 1;
                this.velocity = velocity || {
                    x: (Math.random() - 0.5) * 15,
                    y: (Math.random() - 0.5) * 15
                };
                this.friction = 0.96;
                this.gravity = 0.12; // 稍微减弱重力，让心形保持更久
                this.opacity = 1;
            }
            draw() {
                fwCtx.save();
                fwCtx.globalAlpha = this.opacity;
                fwCtx.beginPath();
                fwCtx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                fwCtx.fillStyle = this.color;
                fwCtx.shadowBlur = 15;
                fwCtx.shadowColor = this.color;
                fwCtx.fill();
                fwCtx.restore();
            }
            update() {
                this.velocity.x *= this.friction;
                this.velocity.y *= this.friction;
                this.velocity.y += this.gravity;
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                this.opacity -= 0.012;
            }
        }

        class Firework {
            constructor(x, targetY, color) {
                this.x = x;
                this.y = height;
                this.targetY = targetY;
                this.color = color;
                this.velocity = {
                    x: (Math.random() - 0.5) * 4,
                    y: -Math.random() * 6 - 18 // 稍微提高初始速度
                };
                this.particles = [];
                this.exploded = false;
                this.trail = [];
            }
            draw() {
                if (!this.exploded) {
                    fwCtx.beginPath();
                    fwCtx.arc(this.x, this.y, 2, 0, Math.PI * 2); // 减小火种大小
                    fwCtx.fillStyle = this.color;
                    fwCtx.fill();
                    
                    // 优化拖尾效果，绘制渐变线条
                    if (this.trail.length > 1) {
                        fwCtx.beginPath();
                        fwCtx.moveTo(this.trail[0].x, this.trail[0].y);
                        for (let i = 1; i < this.trail.length; i++) {
                            const p = this.trail[i];
                            fwCtx.lineTo(p.x, p.y);
                        }
                        // 创建线性渐变，使拖尾有淡出效果
                        const grad = fwCtx.createLinearGradient(this.x, this.y, this.trail[0].x, this.trail[0].y);
                        grad.addColorStop(0, this.color);
                        grad.addColorStop(1, 'rgba(0,0,0,0)');
                        
                        fwCtx.strokeStyle = grad;
                        fwCtx.lineWidth = 1.5; // 稍微变细
                        fwCtx.lineCap = 'round';
                        fwCtx.stroke();
                    }
                } else {
                    this.particles.forEach(p => p.draw());
                }
            }
            update() {
                if (!this.exploded) {
                    this.trail.push({ x: this.x, y: this.y });
                    if (this.trail.length > 20) this.trail.shift(); // 增加拖尾长度
                    this.x += this.velocity.x;
                    this.y += this.velocity.y;
                    this.velocity.y += 0.12; // 稍微增加重力感
                    if (this.velocity.y >= 0 || this.y <= this.targetY) this.explode();
                } else {
                    for (let i = this.particles.length - 1; i >= 0; i--) {
                        this.particles[i].update();
                        if (this.particles[i].opacity <= 0) this.particles.splice(i, 1);
                    }
                }
            }
            explode() {
                this.exploded = true;
                const particleCount = 300; // 固定的粒子数来形成更好的形状
                for (let i = 0; i < particleCount; i++) {
                    const t = (i / particleCount) * Math.PI * 2;
                    // 优化后的心形公式，减少高频余弦分量，使其更圆润 fuller
                    // 调整基础缩放系数，适当缩小以适应屏幕
                    const vx = 18 * Math.pow(Math.sin(t), 3);
                    const vy = -(15 * Math.cos(t) - 5 * Math.cos(2 * t) - 1.5 * Math.cos(3 * t) - 0.4 * Math.cos(4 * t));
                    
                    // 收紧爆炸力度 (force 减小)，让形状更聚拢且范围更小
                    const force = Math.random() * 0.15 + 0.6; 
                    this.particles.push(new Particle(this.x, this.y, this.color, {
                        x: vx * force * 0.45, // 进一步缩小系数
                        y: vy * force * 0.45
                    }));
                }
            }
        }

        const fireworks = [];
        const colors = ['#ff0000', '#00ffb0', '#00f0ff', '#ffff00', '#ff00ff', '#00ffff', '#fbbeee', '#ff8800', '#ffeb3b', '#e91f63'];

        function animateFireworks() {
            // 将原来的黑色半透明填充改为完全透明清空
            // 这样就不会每一帧都覆盖一层黑色，导致背景图闪烁或看不清
            fwCtx.clearRect(0, 0, width, height);
            
            // 为了保留烟花的拖尾效果，我们需要手动绘制一个极淡的残影层
            // 但不能覆盖整个背景，这里使用 globalCompositeOperation 技巧
            // 或者简单地只重绘烟花，放弃长拖尾以保证背景清晰
            // 这里采用折中方案：不使用全屏黑色遮罩，而是让粒子自带透明度衰减
            
            // 只有在烟花阶段才主动产生随机烟花
            if (isFireworksStage && Math.random() < 0.08) { // 提高烟花密度
                const x = Math.random() * width;
                const targetY = Math.random() * (height * 0.4); // 稍微往上一点
                const color = colors[Math.floor(Math.random() * colors.length)];
                fireworks.push(new Firework(x, targetY, color));
            }
            
            for (let i = fireworks.length - 1; i >= 0; i--) {
                fireworks[i].draw();
                fireworks[i].update();
                if (fireworks[i].exploded && fireworks[i].particles.length === 0) fireworks.splice(i, 1);
            }
            requestAnimationFrame(animateFireworks);
        }

        // --- 彩色爱心逻辑 ---
        const heartSettings = {
            particles: { length: 600, duration: 2, velocity: 120, effect: -0.75, size: 30 },
        };

        class HeartPoint {
            constructor(x, y) { this.x = x || 0; this.y = y || 0; }
            clone() { return new HeartPoint(this.x, this.y); }
            length(l) {
                if (typeof l == 'undefined') return Math.sqrt(this.x * this.x + this.y * this.y);
                this.normalize(); this.x *= l; this.y *= l; return this;
            }
            normalize() { var l = this.length(); this.x /= l; this.y /= l; return this; }
        }

        class HeartParticle {
            constructor() {
                this.position = new HeartPoint();
                this.velocity = new HeartPoint();
                this.acceleration = new HeartPoint();
                this.age = 0;
                this.color = '#ffc0cb';
            }
            initialize(x, y, dx, dy, color) {
                this.position.x = x; this.position.y = y;
                this.velocity.x = dx; this.velocity.y = dy;
                this.acceleration.x = dx * heartSettings.particles.effect;
                this.acceleration.y = dy * heartSettings.particles.effect;
                this.age = 0;
                this.color = color;
            }
            update(deltaTime) {
                this.position.x += this.velocity.x * deltaTime;
                this.position.y += this.velocity.y * deltaTime;
                this.velocity.x += this.acceleration.x * deltaTime;
                this.velocity.y += this.acceleration.y * deltaTime;
                this.age += deltaTime;
            }
            draw(context, images) {
                function ease(t) { return (--t) * t * t + 1; }
                var size = heartSettings.particles.size * ease(this.age / heartSettings.particles.duration);
                context.globalAlpha = 1 - this.age / heartSettings.particles.duration;
                const img = images[this.color] || images['#ffc0cb'];
                context.drawImage(img, this.position.x - size / 2, this.position.y - size / 2, size, size);
            }
        }

        class ParticlePool {
            constructor(length) {
                this.particles = new Array(length);
                for (var i = 0; i < this.particles.length; i++) this.particles[i] = new HeartParticle();
                this.firstActive = 0;
                this.firstFree = 0;
                this.duration = heartSettings.particles.duration;
            }
            add(x, y, dx, dy, color) {
                this.particles[this.firstFree].initialize(x, y, dx, dy, color);
                this.firstFree++;
                if (this.firstFree == this.particles.length) this.firstFree = 0;
                if (this.firstActive == this.firstFree) this.firstActive++;
                if (this.firstActive == this.particles.length) this.firstActive = 0;
            }
            update(deltaTime) {
                if (this.firstActive < this.firstFree) {
                    for (let i = this.firstActive; i < this.firstFree; i++) this.particles[i].update(deltaTime);
                } else if (this.firstFree < this.firstActive) {
                    for (let i = this.firstActive; i < this.particles.length; i++) this.particles[i].update(deltaTime);
                    for (let i = 0; i < this.firstFree; i++) this.particles[i].update(deltaTime);
                }
                while (this.particles[this.firstActive].age >= this.duration && this.firstActive != this.firstFree) {
                    this.firstActive++;
                    if (this.firstActive == this.particles.length) this.firstActive = 0;
                }
            }
            draw(context, images) {
                if (this.firstActive < this.firstFree) {
                    for (let i = this.firstActive; i < this.firstFree; i++) this.particles[i].draw(context, images);
                } else if (this.firstFree < this.firstActive) {
                    for (let i = this.firstActive; i < this.particles.length; i++) this.particles[i].draw(context, images);
                    for (let i = 0; i < this.firstFree; i++) this.particles[i].draw(context, images);
                }
            }
        }

        (function(canvas) {
            var context = canvas.getContext('2d');
            var particles = new ParticlePool(heartSettings.particles.length);
            var particleRate = heartSettings.particles.length / heartSettings.particles.duration;
            var time;

            function pointOnHeart(t) {
                return new HeartPoint(
                    160 * Math.pow(Math.sin(t), 3),
                    130 * Math.cos(t) - 50 * Math.cos(2 * t) - 20 * Math.cos(3 * t) - 10 * Math.cos(4 * t) + 25
                );
            }

            var images = {};
            colors.forEach(color => {
                var c = document.createElement('canvas'), ctx = c.getContext('2d');
                c.width = heartSettings.particles.size; c.height = heartSettings.particles.size;
                function to(t) {
                    var p = pointOnHeart(t);
                    p.x = heartSettings.particles.size / 2 + p.x * heartSettings.particles.size / 350;
                    p.y = heartSettings.particles.size / 2 - p.y * heartSettings.particles.size / 350;
                    return p;
                }
                ctx.beginPath();
                var t = -Math.PI; var p = to(t); ctx.moveTo(p.x, p.y);
                while (t < Math.PI) { t += 0.01; p = to(t); ctx.lineTo(p.x, p.y); }
                ctx.closePath();
                ctx.fillStyle = color;
                ctx.fill();
                var img = new Image(); img.src = c.toDataURL(); images[color] = img;
            });

            function render() {
                requestAnimationFrame(render);
                if (!startHeart) return;
                // 加快爱心展开速度：从 0.005 提升到 0.012
                // 这样只需约 1.5 秒即可完全展开
                if (heartScale < 1) heartScale += 0.02;

                var newTime = new Date().getTime() / 1000, deltaTime = newTime - (time || newTime);
                time = newTime;
                context.clearRect(0, 0, canvas.width, canvas.height);
                
                const amount = particleRate * deltaTime * heartScale;
                for (var i = 0; i < amount; i++) {
                    var pos = pointOnHeart(Math.PI - 2 * Math.PI * Math.random());
                    var dir = pos.clone().length(heartSettings.particles.velocity);
                    var color = colors[Math.floor(Math.random() * colors.length)];
                    
                    // 增大手机端的显示比例系数，从 width/450 增加到 width/300 左右
                    // 确保爱心足够大，能完整包裹住中间的文字
                    const responsiveScale = width < 768 ? (width / 250) : (width / 600);
                    
                    // 微调爱心垂直位置，向上移动一点 (canvas.height / 2 - 20) 以更好地对齐文字中心
                    particles.add(canvas.width / 2 + pos.x * heartScale * responsiveScale, (canvas.height / 2 - 30) - pos.y * heartScale * responsiveScale, dir.x, -dir.y, color);
                }
                particles.update(deltaTime);
                particles.draw(context, images);
            }
            render();
        })(loveCanvas);

        // --- 1111.html 弹窗逻辑集成 ---
        const MESSAGES = [
            "冰冰新年快乐呀", 
            "你是我的小幸运", 
            "遇见你是我最美的意外",
            "我会一直陪着你",
            "冰冰天天开心", 
            "冰冰注意保暖", 
            "你是我心中的日月", 
            "爱你在朝朝暮暮", 
            "愿与你共度余生", 
            "你是我最美的风景", 
            "心有灵犀一点通", 
            "爱意随风起", 
            "你是我温柔的港湾", 
            "执子之手，共赴山海", 
            "爱你如星辰大海", 
            "你是我的人间值得", 
            "冰冰要开心哦", 
            "今天也很喜欢你", 
            "抱抱我的小可爱", 
            "身体健康，吃嘛嘛香", 
            "要照顾好自己", 
            "我家宝贝最可爱", 
            "此生不负相遇", 
            "愿为你撑起一片天", 
            "你的幸福我来守护", 
            "冰冰新年快乐呀",
            "冰冰永远健康美丽",  
            "风雨同舟，不离不弃"
        ];
        const BRIGHT_COLORS = ["#FFD1D1", "#FFF9C4", "#C8E6C9", "#BBDEFB", "#F8BBD0", "#E1BEE7", "#FFE0B2", "#B2EBF2"];

        function createPopup(message, bgColor, x, y) {
            const popup = document.createElement("div");
            popup.className = "love-popup";
            popup.style.left = `${x}px`;
            popup.style.top = `${y}px`;
            popup.style.backgroundColor = bgColor;
            popup.style.border = "none";
            popup.style.boxShadow = "0 10px 20px rgba(255, 192, 203, 0.3)";

            const closeBtn = document.createElement("button");
            closeBtn.className = "popup-close";
            closeBtn.innerHTML = "❤"; // 改为爱心符号
            closeBtn.style.color = "#ff4d4d";
            closeBtn.onclick = () => popup.remove();

            const messageElem = document.createElement("div");
            messageElem.className = "popup-message";
            messageElem.textContent = message;
            // 字体颜色随机变换
            const textColors = ["#d32f2f", "#c2185b", "#7b1fa2", "#512da8", "#303f9f", "#1976d2", "#00796b", "#388e3c", "#afb42b", "#fbc02d", "#ffa000", "#f57c00", "#e64a19"];
            messageElem.style.color = textColors[Math.floor(Math.random() * textColors.length)];

            popup.appendChild(closeBtn);
            popup.appendChild(messageElem);
            document.body.appendChild(popup);
            
            // 自动移除
            setTimeout(() => { if(popup.parentElement) popup.remove(); }, 6000);
        }

        function initPopups() {
            let count = 0;
            const interval = setInterval(() => {
                const message = MESSAGES[Math.floor(Math.random() * MESSAGES.length)];
                const color = BRIGHT_COLORS[Math.floor(Math.random() * BRIGHT_COLORS.length)];
                
                // 优化位置分配：将屏幕划分为 9 个区域，随机选择一个区域生成
                const gridX = Math.floor(Math.random() * 3);
                const gridY = Math.floor(Math.random() * 3);
                const cellW = width / 3;
                const cellH = height / 3;
                
                const x = gridX * cellW + Math.random() * (cellW - 200);
                const y = gridY * cellH + Math.random() * (cellH - 100);
                
                createPopup(message, color, Math.max(10, x), Math.max(10, y));
                count++;
                if (count > 40) clearInterval(interval);
            }, 350); // 稍微增加间隔时间，让弹窗更有节奏感
        }

        // --- 交互与文字逻辑 ---
        const textStr = "冰冰新年快乐呀";
        textStr.split('').forEach((s, i) => {
            const span = document.createElement('span');
            span.className = 'char';
            span.innerText = s;
            loveTextContainer.appendChild(span);
        });

        function showText() {
            const chars = document.querySelectorAll('.char');
            chars.forEach((char, i) => {
                setTimeout(() => {
                    char.classList.add('show');
                    setInterval(() => {
                        // 随机颜色中加入更多紫色系
                        const purpleColors = ['#d02090', '#9400d3', '#8a2be2', '#9932cc', '#ba55d3', '#ff00ff'];
                        const randomColor = Math.random() < 0.5 
                            ? purpleColors[Math.floor(Math.random() * purpleColors.length)] 
                            : colors[Math.floor(Math.random() * colors.length)];
                        
                        char.style.color = randomColor;
                        char.style.textShadow = `0 0 25px ${char.style.color}`;
                    }, 500);
                }, i * 250);
            });
        }

        // --- 时序控制 ---
        resize();
        drawStars();
        animateFireworks();

        // 时序流程逻辑 (送女朋友浪漫格式优化)
        // 2. 烟花逐渐消散后，心形开始展示 (第6秒开始)
        setTimeout(() => {
            startHeart = true;
        }, 6000);

        // 3. 爱心快速展开完成（约1.5秒）并稳定后，文字逐个出场 (第8.5秒开始)
        // 确保爱心完全变大包裹住区域后再显示文字
        setTimeout(() => {
            showText();
        }, 8500);

        // 4. 文字展示完（约2秒）后，延迟2秒浪漫弹窗大量出现 (第12.5秒开始)
        setTimeout(() => {
            initPopups();
        }, 12500);

        function handleInteraction(e) {
            const x = e.clientX || (e.touches && e.touches[0].clientX);
            const y = e.clientY || (e.touches && e.touches[0].clientY);
            if (x && y) {
                const color = colors[Math.floor(Math.random() * colors.length)];
                fireworks.push(new Firework(x, y, color));
            }
            if (music.paused) music.play().catch(() => {});
        }

        window.addEventListener('mousedown', handleInteraction);
        window.addEventListener('touchstart', handleInteraction, { passive: false });

        document.addEventListener("WeixinJSBridgeReady", function () {
            music.play();
        }, false);
    </script>
</body>
</html>
